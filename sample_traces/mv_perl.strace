13887 execve("/usr/bin/perl", ["perl", "mv.pl"], ["LANG=en_US.UTF-8", "LC_CTYPE=en_US.UTF-8", "USER=preston", "LOGNAME=preston", "HOME=/home/preston", "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games", "MAIL=/var/mail/preston", "SHELL=/usr/bin/zsh", "SSH_CLIENT=172.16.48.1 58263 22", "SSH_CONNECTION=172.16.48.1 58263 172.16.48.140 22", "SSH_TTY=/dev/pts/7", "TERM=xterm-256color", "XDG_SESSION_COOKIE=497f848f94f4485badd97209c59c1e68-1490042003.211787-1999755743", "XDG_SESSION_ID=187", "XDG_RUNTIME_DIR=/run/user/1000", "SHLVL=1", "PWD=/home/preston/NYU/CrashSimulator", "OLDPWD=/home/preston", "ZSH=/home/preston/.oh-my-zsh", "PAGER=less", "LESS=-R", "LSCOLORS=Gxfxcxdxbxegedabagacad", "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:", "_=/usr/bin/strace"]) = 0
13887 brk(0)                            = 0x8214000
13887 uname({sysname="Linux", nodename="dev.local", release="3.19.0-49-generic", version="#55-Ubuntu SMP Fri Jan 22 02:09:44 UTC 2016", machine="i686", domainname="(none)"}) = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fda000
13887 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
13887 open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1053019, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=200, st_size=100607, st_atime=2017/03/20-19:01:42, st_mtime=2017/03/13-22:17:12, st_ctime=2017/03/13-22:17:12}) = 0
13887 mmap2(NULL, 100607, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fc1000
13887 close(3)                          = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 open("/lib/i386-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
13887 read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220\n\0\0004\0\0\0h1\0\0\0\0\0\0004\0 \0\7\0(\0\35\0\34\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0@$\0\0@$\0\0\5\0\0\0\0\20\0\0\1\0\0\0\260.\0\0\260>\0\0\260>\0\0\240\1\0\0\320\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\304.\0\0\304>\0\0\304>\0\0\10\1\0\0\10\1\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td\254\31\0\0\254\31\0\0\254\31\0\0\324\0\0\0\324\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\260.\0\0\260>\0\0\260>\0\0P\1\0\0P\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0?\357\26lo\307y\212\\u\270\302\33\326\361{\345\251S\254\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0 \0\0\0\26\0\0\0\32\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\32\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\34\0\0\0\35\0\0\0\0\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\"\0\0\0#\0\0\0\0\0\0\0\0\0\0\0$\0\0\0&\0\0\0'\0\0\0\0\0\0\0)\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30`\242\222\6\257\304M\17\325=l\366\327=l\366\352\26\251\30\371\31sB", 512) = 512
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1051898, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=32, st_size=13808, st_atime=2017/03/20-19:01:42, st_mtime=2015/03/26-07:01:21, st_ctime=2015/09/26-01:26:32}) = 0
13887 mmap2(NULL, 16512, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7fbc000
13887 mmap2(0xb7fbf000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0xb7fbf000
13887 close(3)                          = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 open("/lib/i386-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
13887 read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320E\0\0004\0\0\0\314\262\4\0\0\0\0\0004\0 \0\7\0(\0\37\0\36\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0008\246\4\0008\246\4\0\5\0\0\0\0\20\0\0\1\0\0\0\264\256\4\0\264\276\4\0\264\276\4\0\250\1\0\0\354\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\300\256\4\0\300\276\4\0\300\276\4\0\20\1\0\0\20\1\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345tdX\360\3\0X\360\3\0X\360\3\0l\17\0\0l\17\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\264\256\4\0\264\276\4\0\264\276\4\0L\1\0\0L\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\3037~\241\217(B8\23\312\351n\210\27\277{\3545\373\336\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0 \0\0\0002\3\0\0\24\0\0\0\200\0\0\0\f\0\0\0%\0@ \0\240.\2\0\0\4)\200 W\202B\10\200  aH\312\0\t\0\0\0\0\0\0\0\0\0\0\0\0\212P\20\1\0\300\0\4\t\202\24\1\344\200&\0\204\253\20\240\212\2\316\0\212\4\0\0\0P\0\4 \0\0\4\4\5\r\7\7\27I\0\0\0\0\0\1@\0\t\0\24\4D\30\4@` \22\300\5\t\nE\225\0\1\200\0102@\0\0\0\0\0\0\0\0\4\2\0\0\0@\0\200\3\0\302\200\0\30\24\301`E\1\0\210#\0\4\2\0\200\0\4\0\2\0", 512) = 512
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1051939, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=608, st_size=309156, st_atime=2017/03/20-19:01:42, st_mtime=2015/03/26-07:01:21, st_ctime=2015/09/26-01:26:32}) = 0
13887 mmap2(NULL, 311456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7f6f000
13887 mmap2(0xb7fba000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x4a000) = 0xb7fba000
13887 close(3)                          = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 open("/lib/i386-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
13887 read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220O\0\0004\0\0\0\24\21\2\0\0\0\0\0004\0 \0\7\0(\0(\0%\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0X\204\1\0X\204\1\0\5\0\0\0\0\20\0\0\1\0\0\0\200\215\1\0\200\235\1\0\200\235\1\0\370\3\0\0L%\0\0\6\0\0\0\0\20\0\0\2\0\0\0\230\216\1\0\230\236\1\0\230\236\1\0\30\1\0\0\30\1\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td`-\1\0`-\1\0`-\1\0\34\t\0\0\34\t\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\200\215\1\0\200\235\1\0\200\235\1\0\200\2\0\0\200\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0M\5\223vK\35\332Hm\214\322\315\311\346\272\341\r\300\326\306\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0 \0\0\0\4\2\0\0Z\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\221Q`\300@\22\213\0020D\0\0\20\1\0\n\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$H\0X(\1\222\34\301B\240\220\22\10\f \2\30dA\245c\4@\n\32\3\0\0)\t(\314D\204\210\314\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300\2248@\20\31\20\0\265\0 \0\200`\0\20 \0\vA\22!-\0P\10\211\22G", 512) = 512
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1052007, st_mode=S_IFREG|0755, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=272, st_size=137044, st_atime=2017/03/20-19:01:42, st_mtime=2015/03/26-07:01:24, st_ctime=2015/09/26-01:26:32}) = 0
13887 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6e000
13887 mmap2(NULL, 115404, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7f51000
13887 mmap2(0xb7f6a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18000) = 0xb7f6a000
13887 mmap2(0xb7f6c000, 4812, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f6c000
13887 close(3)                          = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
13887 read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220\210\1\0004\0\0\0\300\211\33\0\0\0\0\0004\0 \0\n\0(\0E\0D\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\245\241\26\0\245\241\26\0\245\241\26\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2303\33\0\2303\33\0\5\0\0\0\0\20\0\0\1\0\0\0\\?\33\0\\O\33\0\\O\33\0\2700\0\0\200_\0\0\6\0\0\0\0\20\0\0\2\0\0\0\244]\33\0\244m\33\0\244m\33\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\\?\33\0\\O\33\0\\O\33\0\10\0\0\0L\0\0\0\4\0\0\0\4\0\0\0P\345td\270\241\26\0\270\241\26\0\270\241\26\0\244`\0\0\244`\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\\?\33\0\\O\33\0\\O\33\0\244 \0\0\244 \0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0%\335B\217\264\303P\301m\376\342\4\221\361\240d\204\242\277\243\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0 \0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0E\200\0`\300\200\0\f\212\f\0\0010\0\10@2\10\256\4\210H6l\240\0268\0&\204\200\216\4\10B$", 512) = 512
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1051883, st_mode=S_IFREG|0755, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=3536, st_size=1807496, st_atime=2017/03/20-19:01:42, st_mtime=2015/03/26-07:01:21, st_ctime=2015/09/26-01:26:32}) = 0
13887 mmap2(NULL, 1814236, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7d96000
13887 mmap2(0xb7f4a000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b3000) = 0xb7f4a000
13887 mmap2(0xb7f4f000, 7900, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4f000
13887 close(3)                          = 0
13887 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13887 open("/lib/i386-linux-gnu/libcrypt.so.1", O_RDONLY|O_CLOEXEC) = 3
13887 read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320\10\0\0004\0\0\0\200\221\0\0\0\0\0\0004\0 \0\7\0(\0\35\0\34\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\304\202\0\0\304\202\0\0\5\0\0\0\0\20\0\0\1\0\0\0\310\216\0\0\310\236\0\0\310\236\0\0\234\1\0\0\324r\2\0\6\0\0\0\0\20\0\0\2\0\0\0\324\216\0\0\324\236\0\0\324\236\0\0\10\1\0\0\10\1\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td\0u\0\0\0u\0\0\0u\0\0004\1\0\0004\1\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\310\216\0\0\310\236\0\0\310\236\0\0008\1\0\0008\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\266;X\237pG\375g\307F\2444]CH\302)|\0i\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0 \0\0\0\17\0\0\0\32\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\35\0\0\0\36\0\0\0\0\0\0\0\37\0\0\0\0\0\0\0 \0\0\0!\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0 \0\0\0p\0\0\0\0\0\0\0\0\0\0\0\26\0\0\0\262\0\0\0", 512) = 512
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=1051891, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=80, st_size=38408, st_atime=2017/03/20-19:01:42, st_mtime=2015/03/26-07:01:21, st_ctime=2015/09/26-01:26:32}) = 0
13887 mmap2(NULL, 201116, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7d64000
13887 mmap2(0xb7d6d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x8000) = 0xb7d6d000
13887 mmap2(0xb7d6f000, 156060, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d6f000
13887 close(3)                          = 0
13887 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d63000
13887 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d63980, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
13887 mprotect(0xb7f4a000, 12288, PROT_READ) = 0
13887 mprotect(0xb7d6d000, 4096, PROT_READ) = 0
13887 mprotect(0xb7f6a000, 4096, PROT_READ) = 0
13887 mprotect(0xb7fba000, 4096, PROT_READ) = 0
13887 mprotect(0xb7fbf000, 4096, PROT_READ) = 0
13887 mprotect(0x8211000, 4096, PROT_READ) = 0
13887 mprotect(0xb7ffe000, 4096, PROT_READ) = 0
13887 munmap(0xb7fc1000, 100607)        = 0
13887 set_tid_address(0xb7d639e8)       = 13887
13887 set_robust_list(0xb7d639f0, 12)   = 0
13887 rt_sigaction(SIGRTMIN, {0xb7f55a10, [], SA_RESTORER|SA_SIGINFO, 0xb7f60b90}, NULL, 8) = 0
13887 rt_sigaction(SIGRT_1, {0xb7f55a90, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0xb7f60b90}, NULL, 8) = 0
13887 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
13887 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
13887 uname({sysname="Linux", nodename="dev.local", release="3.19.0-49-generic", version="#55-Ubuntu SMP Fri Jan 22 02:09:44 UTC 2016", machine="i686", domainname="(none)"}) = 0
13887 rt_sigaction(SIGFPE, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0xb7dc20f8}, {SIG_DFL, [], 0}, 8) = 0
13887 brk(0)                            = 0x8214000
13887 brk(0x8235000)                    = 0x8235000
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE|O_CLOEXEC) = 3
13887 fstat64(3, {st_dev=makedev(8, 1), st_ino=661168, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=5704, st_size=2919792, st_atime=2017/03/20-19:01:42, st_mtime=2015/09/26-01:34:29, st_ctime=2015/09/26-01:34:29}) = 0
13887 mmap2(NULL, 2097152, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7b63000
13887 mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0x2c5000) = 0xb7fd9000
13887 close(3)                          = 0
13887 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 3
13887 read(3, "J\31\326a", 4)           = 4
13887 close(3)                          = 0
13887 time([1490042168])                = 1490042168
13887 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
13887 stat64("/usr/local/lib/site_perl/5.20.2/i686-linux-gnu-thread-multi-64int", 0xbffff25c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/site_perl/5.20.2", 0xbffff25c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/site_perl/i686-linux-gnu-thread-multi-64int", 0xbffff25c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.1", 0xbffff3cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.1", 0xbffff3cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.0", 0xbffff3cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.0", 0xbffff3cc) = -1 ENOENT (No such file or directory)
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 ioctl(0, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, {c_iflags=0x2d00, c_oflags=0x5, c_cflags=0xbf, c_lflags=0xca3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\xff\x12\x0f\x17\x16\xff\x00\x00"}) = 0
13887 _llseek(0, 0, 0xbffff058, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13887 ioctl(1, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, {c_iflags=0x2d00, c_oflags=0x5, c_cflags=0xbf, c_lflags=0xca3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\xff\x12\x0f\x17\x16\xff\x00\x00"}) = 0
13887 _llseek(1, 0, 0xbffff058, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13887 ioctl(2, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, {c_iflags=0x2d00, c_oflags=0x5, c_cflags=0xbf, c_lflags=0xca3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\xff\x12\x0f\x17\x16\xff\x00\x00"}) = 0
13887 _llseek(2, 0, 0xbffff058, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13887 open("mv.pl", O_RDONLY|O_LARGEFILE) = 3
13887 ioctl(3, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbffff108) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(3, 0, [0], SEEK_CUR)      = 0
13887 fcntl64(3, F_SETFD, FD_CLOEXEC)   = 0
13887 fstat64(3, {st_dev=makedev(0, 40), st_ino=7770, st_mode=S_IFREG|0664, st_nlink=1, st_uid=501, st_gid=20, st_blksize=1024, st_blocks=1, st_size=61, st_atime=2017/03/20-20:36:06, st_mtime=2017/03/20-20:36:06, st_ctime=2017/03/20-20:36:06}) = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 brk(0x8256000)                    = 0x8256000
13887 read(3, "use File::Copy;\n\ncopy(\"/mnt/b/test.txt\", \"/mnt/c/test.txt\");\n", 8192) = 61
13887 stat64("/etc/perl/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Copy.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/File/Copy.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/File/Copy.pm", {st_dev=makedev(8, 1), st_ino=40843, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=32, st_size=15714, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-16:57:19, st_ctime=2016/02/02-19:10:27}) = 0
13887 open("/usr/share/perl/5.20/File/Copy.pm", O_RDONLY|O_LARGEFILE) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffeb68) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 read(4, "# File/Copy.pm. Written in 1994 by Aaron Sherman <ajs@ajs.com>. This\n# source code has been placed in the public domain by the author.\n# Please be kind and preserve the documentation.\n#\n# Additions copyright 1996 by Charles Bailey.  Permission is granted\n# to distribute the revised code under the same terms as Perl itself.\n\npackage File::Copy;\n\nuse 5.006;\nuse strict;\nuse warnings; no warnings 'newline';\nuse File::Spec;\nuse Config;\n# During perl build, we need File::Copy but Scalar::Util might not be built yet\n# And then we need these games to avoid loading overload, as that will\n# confuse miniperl during the bootstrap of perl.\nmy $Scalar_Util_loaded = eval q{ require Scalar::Util; require overload; 1 };\nour(@ISA, @EXPORT, @EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy);\nsub copy;\nsub syscopy;\nsub cp;\nsub mv;\n\n$VERSION = '2.30';\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(copy move);\n@EXPORT_OK = qw(cp mv);\n\n$Too_Big = 1024 * 1024 * 2;\n\nsub croak {\n    require Carp;\n    goto &Carp::croak;\n}\n\nsub carp {\n    require Carp;\n    goto &Carp::carp;\n}\n\nsub _catname {\n    my($from, $to) = @_;\n    if (not defined &basename) {\n\trequire File::Basename;\n\timport  File::Basename 'basename';\n    }\n\n    return File::Spec->catfile($to, basename($from));\n}\n\n# _eq($from, $to) tells whether $from and $to are identical\nsub _eq {\n    my ($from, $to) = map {\n        $Scalar_Util_loaded && Scalar::Util::blessed($_)\n\t    && overload::Method($_, q{\"\"})\n            ? \"$_\"\n            : $_\n    } (@_);\n    return '' if ( (ref $from) xor (ref $to) );\n    return $from == $to if ref $from;\n    return $from eq $to;\n}\n\nsub copy {\n    croak(\"Usage: copy(FROM, TO [, BUFFERSIZE]) \")\n      unless(@_ == 2 || @_ == 3);\n\n    my $from = shift;\n    my $to = shift;\n\n    my $size;\n    if (@_) {\n\t$size = shift(@_) + 0;\n\tcroak(\"Bad buffer size for copy: $size\\n\") unless ($size > 0);\n    }\n\n    my $from_a_handle = (ref($from)\n\t\t\t ? (ref($from) eq 'GLOB'\n\t\t\t    || UNIVERSAL::isa($from, 'GLOB')\n                            || UNIVERSAL::isa($from, 'IO::Handle'))\n\t\t\t : (ref(\\$from) eq 'GLOB'));\n    my $to_a_handle =   (ref($to)\n\t\t\t ? (ref($to) eq 'GLOB'\n\t\t\t    || UNIVERSAL::isa($to, 'GLOB')\n                            || UNIVERSAL::isa($to, 'IO::Handle'))\n\t\t\t : (ref(\\$to) eq 'GLOB'));\n\n    if (_eq($from, $to)) { # works for references, too\n\tcarp(\"'$from' and '$to' are identical (not copied)\");\n        return 0;\n    }\n\n    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {\n\t$to = _catname($from, $to);\n    }\n\n    if ((($Config{d_symlink} && $Config{d_readlink}) || $Config{d_link}) &&\n\t!($^O eq 'MSWin32' || $^O eq 'os2')) {\n\tmy @fs = stat($from);\n\tif (@fs) {\n\t    my @ts = stat($to);\n\t    if (@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1] && !-p $from) {\n\t\tcarp(\"'$from' and '$to' are identical (not copied)\");\n                return 0;\n\t    }\n\t}\n    }\n    elsif (_eq($from, $to)) {\n\tcarp(\"'$from' and '$to' are identical (not copied)\");\n\treturn 0;\n    }\n\n    if (defined &syscopy && !$Syscopy_is_copy\n\t&& !$to_a_handle\n\t&& !($from_a_handle && $^O eq 'os2' )\t# OS/2 cannot handle handles\n\t&& !($from_a_handle && $^O eq 'MSWin32')\n\t&& !($from_a_handle && $^O eq 'NetWare')\n       )\n    {\n        if ($^O eq 'VMS' && -e $from\n            && ! -d $to && ! -d $from) {\n\n            # VMS natively inherits path components from the source of a\n            # copy, but we want the Unixy behavior of inheriting from\n            # the current working directory.  Also, default in a trailing\n            # dot for null file types.\n\n            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');\n\n            # Get rid of the old versions to be like UNIX\n            1 while unlink $to;\n        }\n\n        return syscopy($from, $to) || 0;\n    }\n\n    my $closefrom = 0;\n    my $closeto = 0;\n    my ($status, $r, $buf);\n    local($\\) = '';\n\n    my $from_h;\n    if ($from_a_handle) {\n       $from_h = $from;\n    } else {\n       open $from_h, \"<\", $from or goto fail_open1;\n       binmode $from_h or die \"($!,$^E)\";\n       $closefrom = 1;\n    }\n\n    # Seems most logical to do this here, in case future changes would want to\n    # make this croak for some reason.\n    unless (defined $size) {\n\t$size = tied(*$from_h) ? 0 : -s $from_h || 0;\n\t$size = 1024 if ($size < 512);\n\t$size = $Too_Big if ($size > $Too_Big);\n    }\n\n    my $to_h;\n    if ($to_a_handle) {\n       $to_h = $to;\n    } else {\n\t$to_h = \\do { local *FH }; # XXX is this line obsolete?\n\topen $to_h, \">\", $to or goto fail_open2;\n\tbinmode $to_h or die \"($!,$^E)\";\n\t$closeto = 1;\n    }\n\n    $! = 0;\n    for (;;) {\n\tmy ($r, $w, $t);\n       defined($r = sysread($from_h, $buf, $size))\n\t    or goto fail_inner;\n\tlast unless $r;\n\tfor ($w = 0; $w < $r; $w += $t) {\n           $t = syswrite($to_h, $buf, $r - $w, $w)\n\t\tor goto fail_inner;\n\t}\n    }\n\n    close($to_h) || goto fail_open2 if $closeto;\n    close($from_h) || goto fail_open1 if $closefrom;\n\n    # Use this idiom to avoid uninitialized value warning.\n    return 1;\n\n    # All of these contortions try to preserve error messages...\n  fail_inner:\n    if ($closeto) {\n\t$status = $!;\n\t$! = 0;\n       close $to_h;\n\t$! = $status unless $!;\n    }\n  fail_open2:\n    if ($closefrom) {\n\t$status = $!;\n\t$! = 0;\n       close $from_h;\n\t$! = $status unless $!;\n    }\n  fail_open1:\n    return 0;\n}\n\nsub cp {\n    my($from,$to) = @_;\n    my(@fromstat) = stat $from;\n    my(@tostat) = stat $to;\n    my $perm;\n\n    return 0 unless copy(@_) and @fromstat;\n\n    if (@tostat) {\n        $perm = $tostat[2];\n    } else {\n        $perm = $fromstat[2] & ~(umask || 0);\n\t@tostat = stat $to;\n    }\n    # Might be more robust to look for S_I* in Fcntl, but we're\n    # trying to avoid dependence on any XS-containing modules,\n    # since File::Copy is used during the Perl build.\n    $perm &= 07777;\n    if ($perm & 06000) {\n\tcroak(\"Unable to check setuid/setgid permissions for $to: $!\")\n\t    unless @tostat;\n\n\tif ($perm & 04000 and                     # setuid\n\t    $fromstat[4] != $tostat[4]) {         # owner must match\n\t    $perm &= ~06000;\n\t}\n\n\tif ($perm & 02000 && $> != 0) {           # if not root, setgid\n\t    my $ok = $fromstat[5] == $tostat[5];  # group must match\n\t    if ($ok) {                            # and we must be in group\n                $ok = grep { $_ == $fromstat[5] } split /\\s+/, $)\n\t    }\n\t    $perm &= ~06000 unless $ok;\n\t}\n    }\n    return 0 unless @tostat;\n    return 1 if $perm == ($tostat[2] & 07777);\n    return eval { chmod $perm, $to; } ? 1 : 0;\n}\n\nsub _move {\n    croak(\"Usage: move(FROM, TO) \") unless @_ == 3;\n\n    my($from,$to,$fallback) = @_;\n\n    my($fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);\n\n    if (-d $to && ! -d $from) {\n\t$to = _catname($from, $to);\n    }\n\n    ($tosz1,$tomt1) = (stat($to))[7,9];\n    $fromsz = -s $from;\n    if ($^O eq 'os2' and defined $tosz1 and defined $fromsz) {\n      # will not rename with overwrite\n      unlink $to;\n    }\n\n    if ($^O eq 'VMS' && -e $from\n        && ! -d $to && ! -d $from) {\n\n            # VMS natively inherits path components from the source of a\n            # copy, but we want the Unixy behavior of inheriting from\n            # the current working directory.  Also, default in a trailing\n            # dot for null file types.\n\n            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');\n\n            # Get rid of the old versions to be like UNIX\n            1 while unlink $to;\n    }\n\n    return 1 if rename $from, $to;\n\n    # Did rename return an error even though it succeeded, because $to\n    # is on a remote NFS file system, and NFS lost the server's ack?\n    return 1 if defined($fromsz) && !-e $from &&           # $from disappeared\n                (($tosz2,$tomt2) = (stat($to))[7,9]) &&    # $to's there\n                  ((!defined $tosz1) ||\t\t\t   #  not before or\n\t\t   ($tosz1 != $tosz2 or $tomt1 != $tomt2)) &&  #   was changed\n                $tosz2 == $fromsz;                         # it's all there\n\n    ($tosz1,$tomt1) = (stat($to))[7,9];  # just in case rename did something\n\n    {\n        local $@;\n        eval {\n            local $SIG{__DIE__};\n            $fallback->($from,$to) or die;\n            my($atime, $mtime) = (stat($from))[8,9];\n         ", 8192) = 8192
13887 stat64("/etc/perl/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/strict.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/strict.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/strict.pm", {st_dev=makedev(8, 1), st_ino=923340, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=1006, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/strict.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "package strict;\n\n$strict::VERSION = \"1.08\";\n\n# Verify that we're called correctly so that strictures will work.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    # Can't use Carp, since Carp uses us!\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\nmy %explicit_bitmask = (\nrefs => 0x00000020,\nsubs => 0x00000040,\nvars => 0x00000080\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tif (exists $bitmask{$s}) {\n\t    $^H |= $explicit_bitmask{$s};\n\t}\n\telse { push @wrong, $s };\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown 'strict' tag(s) '@wrong'\");\n    }\n    $bits;\n}\n\nmy @default_bits = qw(refs subs vars);\n\nsub import {\n    shift;\n    $^H |= bits(@_ ? @_ : @default_bits);\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ bits(@_ ? @_ : @default_bits);\n}\n\n1;\n__END__\n\n", 8192) = 1006
13887 _llseek(5, 1005, [1005], SEEK_SET) = 0
13887 _llseek(5, 0, [1005], SEEK_CUR)   = 0
13887 close(5)                          = 0
13887 stat64("/etc/perl/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/warnings.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/warnings.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/warnings.pm", {st_dev=makedev(8, 1), st_ino=958541, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=40, st_size=18622, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/warnings.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file is built by regen/warnings.pl.\n# Any changes made here will be lost!\n\npackage warnings;\n\nour $VERSION = '1.23';\n\n# Verify that we're called correctly so that warnings will work.\n# see also strict.pm.\nunless ( __FILE__ =~ /(^|[\\/\\\\])\\Q${\\__PACKAGE__}\\E\\.pmc?$/ ) {\n    my (undef, $f, $l) = caller;\n    die(\"Incorrect use of pragma '${\\__PACKAGE__}' at $f line $l.\\n\");\n}\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    'all'\t\t=> 0,\n    'closure'\t\t=> 2,\n    'deprecated'\t=> 4,\n    'exiting'\t\t=> 6,\n    'glob'\t\t=> 8,\n    'io'\t\t=> 10,\n    'closed'\t\t=> 12,\n    'exec'\t\t=> 14,\n    'layer'\t\t=> 16,\n    'newline'\t\t=> 18,\n    'pipe'\t\t=> 20,\n    'unopened'\t\t=> 22,\n    'misc'\t\t=> 24,\n    'numeric'\t\t=> 26,\n    'once'\t\t=> 28,\n    'overflow'\t\t=> 30,\n    'pack'\t\t=> 32,\n    'portable'\t\t=> 34,\n    'recursion'\t\t=> 36,\n    'redefine'\t\t=> 38,\n    'regexp'\t\t=> 40,\n    'severe'\t\t=> 42,\n    'debugging'\t\t=> 44,\n    'inplace'\t\t=> 46,\n    'internal'\t\t=> 48,\n    'malloc'\t\t=> 50,\n    'signal'\t\t=> 52,\n    'substr'\t\t=> 54,\n    'syntax'\t\t=> 56,\n    'ambiguous'\t\t=> 58,\n    'bareword'\t\t=> 60,\n    'digit'\t\t=> 62,\n    'parenthesis'\t=> 64,\n    'precedence'\t=> 66,\n    'printf'\t\t=> 68,\n    'prototype'\t\t=> 70,\n    'qw'\t\t=> 72,\n    'reserved'\t\t=> 74,\n    'semicolon'\t\t=> 76,\n    'taint'\t\t=> 78,\n    'threads'\t\t=> 80,\n    'uninitialized'\t=> 82,\n    'unpack'\t\t=> 84,\n    'untie'\t\t=> 86,\n    'utf8'\t\t=> 88,\n    'void'\t\t=> 90,\n\n    # Warnings Categories added in Perl 5.011\n\n    'imprecision'\t=> 92,\n    'illegalproto'\t=> 94,\n\n    # Warnings Categories added in Perl 5.013\n\n    'non_unicode'\t=> 96,\n    'nonchar'\t\t=> 98,\n    'surrogate'\t\t=> 100,\n\n    # Warnings Categories added in Perl 5.017\n\n    'experimental'\t=> 102,\n    'experimental::lexical_subs'=> 104,\n    'experimental::lexical_topic'=> 106,\n    'experimental::regex_sets'=> 108,\n    'experimental::smartmatch'=> 110,\n\n    # Warnings Categories added in Perl 5.019\n\n    'experimental::autoderef'=> 112,\n    'experimental::postderef'=> 114,\n    'experimental::signatures'=> 116,\n    'syscalls'\t\t=> 118,\n  );\n\nour %Bits = (\n    'all'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\", # [0..59]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecated'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'experimental'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x55\\x15\", # [51..58]\n    'experimental::autoderef'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [56]\n    'experimental::lexical_subs'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [52]\n    'experimental::lexical_topic'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [53]\n    'experimental::postderef'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [57]\n    'experimental::regex_sets'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [54]\n    'experimental::signatures'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [58]\n    'experimental::smartmatch'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [55]\n    'glob'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\", # [5..11,59]\n    'layer'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x40\\x00\\x00\\x00\", # [28..38,47]\n    'syscalls'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\", # [59]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x15\\x00\\x00\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [45]\n  );\n\nour %DeadBits = (\n    'all'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\", # [0..59]\n    'ambiguous'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [29]\n    'bareword'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [30]\n    'closed'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    'closure'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    'debugging'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    'deprecat", 8192) = 8192
13887 read(5, "ed'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    'digit'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [31]\n    'exec'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    'exiting'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    'experimental'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xaa\\x2a\", # [51..58]\n    'experimental::autoderef'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [56]\n    'experimental::lexical_subs'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [52]\n    'experimental::lexical_topic'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [53]\n    'experimental::postderef'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [57]\n    'experimental::regex_sets'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\", # [54]\n    'experimental::signatures'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [58]\n    'experimental::smartmatch'=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [55]\n    'glob'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    'illegalproto'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [47]\n    'imprecision'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [46]\n    'inplace'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    'internal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [24]\n    'io'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\", # [5..11,59]\n    'layer'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    'malloc'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [25]\n    'misc'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    'newline'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    'non_unicode'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [48]\n    'nonchar'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [49]\n    'numeric'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    'once'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    'overflow'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    'pack'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    'parenthesis'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [32]\n    'pipe'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    'portable'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    'precedence'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\", # [33]\n    'printf'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [34]\n    'prototype'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [35]\n    'qw'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [36]\n    'recursion'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    'redefine'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    'regexp'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    'reserved'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [37]\n    'semicolon'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [38]\n    'severe'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    'signal'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [26]\n    'substr'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [27]\n    'surrogate'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [50]\n    'syntax'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x80\\x00\\x00\\x00\", # [28..38,47]\n    'syscalls'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\", # [59]\n    'taint'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [39]\n    'threads'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\", # [40]\n    'uninitialized'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [41]\n    'unopened'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    'unpack'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [42]\n    'untie'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [43]\n    'utf8'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x2a\\x00\\x00\", # [44,48..50]\n    'void'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [45]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$DEFAULT  = \"\\x10\\x01\\x00\\x00\\x00\\x50\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x15\", # [2,56,52,53,57,54,58,55,4,22,23,25]\n$LAST_BIT = 120 ;\n$BYTES    = 15 ;\n\n$All = \"\" ; vec($All, $Offsets{'all'}, 2) = 3 ;\n\nsub Croaker\n{\n    require Carp; # this initializes %CarpInternal\n    local $Carp::CarpInternal{'warnings'};\n    delete $Carp::CarpInternal{'warnings'};\n    Carp::croak(@_);\n}\n\nsub _bits {\n    my $mask = shift ;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq 'NONFATAL') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    return $mask ;\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n    push @_, 'all' unless @_ ;\n    return _bits(undef, @_) ;\n}\n\nsub import\n{\n    shift;\n\n    my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n\n    # append 'all' when implied (after a lone \"FATAL\" or \"NONFATAL\")\n    push @_, 'all' if @_==1 && ( $_[0] eq 'FATAL' || $_[0] eq 'NONFATAL' );\n\n    # Empty @_ is equivalent to @_ = 'all' ;\n    ${^WARNING_BITS} = @_ ? _bits($mask, @_) : $mask | $Bits{all} ;\n}\n\nsub unimport\n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;\n\n    if (vec($mask, $Offsets{'all'}, 1)) {\n        $mask |= $Bits{'all'} ;\n        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);\n    }\n\n    # append 'all' when implied (empty import list or after a lone \"FATAL\")\n    push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL';\n\n    foreach my $word ( @_ ) {\n\tif ($word eq 'FATAL') {\n\t    next;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category '$word'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub MESSAGE () { 4 };\nsub FATAL () { 2 };\nsub NORMAL () { 1 };\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n    my $wanted = shift;\n    my $has_message = $wanted & MESSAGE;\n\n    unless (@_ == 1 || @_ == ($has_message ? 2 : 0)) {\n\tmy $sub = (caller 1)[3];\n\tmy $syntax = $has_message ? \"[category,] 'message'\" : '[category]';\n\tCroaker(\"Usage: $sub($syntax)\");\n    }\n\n    my $message = pop if $has_message;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category '$category'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package '$category' not registered for ", 8192) = 8192
13887 brk(0x8277000)                    = 0x8277000
13887 read(5, "warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $i;\n\n    if ($isobj) {\n        my $pkg;\n        $i = 2;\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        $i = _error_loc(); # see where Carp will allocate the error\n    }\n\n    # Default to 0 if caller returns nothing.  Default to $DEFAULT if it\n    # explicitly returns undef.\n    my(@callers_bitmask) = (caller($i))[9] ;\n    my $callers_bitmask =\n\t @callers_bitmask ? $callers_bitmask[0] // $DEFAULT : 0 ;\n\n    my @results;\n    foreach my $type (FATAL, NORMAL) {\n\tnext unless $wanted & $type;\n\n\tpush @results, (vec($callers_bitmask, $offset + $type - 1, 1) ||\n\t\t\tvec($callers_bitmask, $Offsets{'all'} + $type - 1, 1));\n    }\n\n    # &enabled and &fatal_enabled\n    return $results[0] unless $has_message;\n\n    # &warnif, and the category is neither enabled as warning nor as fatal\n    return if $wanted == (NORMAL | FATAL | MESSAGE)\n\t&& !($results[0] || $results[1]);\n\n    require Carp;\n    Carp::croak($message) if $results[0];\n    # will always get here for &warn. will only get here for &warnif if the\n    # category is enabled\n    Carp::carp($message);\n}\n\nsub _mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub register_categories\n{\n    my @names = @_;\n\n    for my $name (@names) {\n\tif (! defined $Bits{$name}) {\n\t    $Bits{$name}     = _mkMask($LAST_BIT);\n\t    vec($Bits{'all'}, $LAST_BIT, 1) = 1;\n\t    $Offsets{$name}  = $LAST_BIT ++;\n\t    foreach my $k (keys %Bits) {\n\t\tvec($Bits{$k}, $LAST_BIT, 1) = 0;\n\t    }\n\t    $DeadBits{$name} = _mkMask($LAST_BIT);\n\t    vec($DeadBits{'all'}, $LAST_BIT++, 1) = 1;\n\t}\n    }\n}\n\nsub _error_loc {\n    require Carp;\n    goto &Carp::short_error_loc; # don't introduce another stack frame\n}\n\nsub enabled\n{\n    return __chk(NORMAL, @_);\n}\n\nsub fatal_enabled\n{\n    return __chk(FATAL, @_);\n}\n\nsub warn\n{\n    return __chk(FATAL | MESSAGE, @_);\n}\n\nsub warnif\n{\n    return __chk(NORMAL | FATAL | MESSAGE, @_);\n}\n\n# These are not part of any public interface, so we can delete them to save\n# space.\ndelete @warnings::{qw(NORMAL FATAL MESSAGE)};\n\n1;\n\n# ex: set ro:\n", 8192) = 2238
13887 read(5, "", 8192)                 = 0
13887 close(5)                          = 0
13887 stat64("/etc/perl/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/File/Spec.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Spec.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Spec.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Spec.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Spec.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec.pm", {st_dev=makedev(8, 1), st_ino=656024, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=592, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = '3.48_01';\n$VERSION =~ tr/_//;\n\nmy %module = (MacOS   => 'Mac',\n\t      MSWin32 => 'Win32',\n\t      os2     => 'OS2',\n\t      VMS     => 'VMS',\n\t      epoc    => 'Epoc',\n\t      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => 'Cygwin');\n\nmy $module = $module{$^O} || 'Unix';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 8192) = 592
13887 stat64("/etc/perl/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/vars.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/vars.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/vars.pm", {st_dev=makedev(8, 1), st_ino=958529, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=1149, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/vars.pm", O_RDONLY|O_LARGEFILE) = 6
13887 ioctl(6, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe1c8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(6, 0, [0], SEEK_CUR)      = 0
13887 read(6, "package vars;\n\nuse 5.006;\n\nour $VERSION = '1.03';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my (undef, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can't declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits('vars'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"'$_' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"'$_' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"'$_' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 8192) = 1149
13887 stat64("/etc/perl/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/warnings/register.pm", 0xbfffdf2c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/warnings/register.pmc", 0xbfffdfcc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/warnings/register.pm", {st_dev=makedev(8, 1), st_ino=150819, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=481, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 7
13887 ioctl(7, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffdcf8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(7, 0, [0], SEEK_CUR)      = 0
13887 read(7, "package warnings::register;\n\nour $VERSION = '1.03';\n\nrequire warnings;\n\n# left here as cruft in case other users were using this undocumented routine\n# -- rjbs, 2010-09-08\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my @categories = @_;\n\n    my $package = (caller(0))[0];\n    warnings::register_categories($package);\n\n    warnings::register_categories($package . \"::$_\") for @categories;\n}\n\n1;\n", 8192) = 481
13887 read(7, "", 8192)                 = 0
13887 close(7)                          = 0
13887 brk(0x8298000)                    = 0x8298000
13887 _llseek(6, 1148, [1148], SEEK_SET) = 0
13887 _llseek(6, 0, [1148], SEEK_CUR)   = 0
13887 close(6)                          = 0
13887 _llseek(5, 591, [591], SEEK_SET)  = 0
13887 _llseek(5, 0, [591], SEEK_CUR)    = 0
13887 close(5)                          = 0
13887 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/File/Spec/Unix.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/File/Spec/Unix.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/File/Spec/Unix.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec/Unix.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec/Unix.pm", {st_dev=makedev(8, 1), st_ino=656025, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=24, st_size=9699, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = '3.48_01';\nmy $xs_version = $VERSION;\n$VERSION =~ tr/_//;\n\nunless (defined &canonpath) {\n  eval {\n    if ( $] >= 5.006 ) {\n\trequire XSLoader;\n\tXSLoader::load(\"Cwd\", $xs_version);\n    } else {\n\trequire Cwd;\n    }\n  };\n}\n\nsub _pp_canonpath {\n    my ($self,$path) = @_;\n    return unless defined $path;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = '';\n    my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';\n\n    if ( $double_slashes_special\n         && ( $path =~ s{^(//[^/]+)/?\\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless ($^O eq 'cygwin');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn't get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx\n    $path =~ s{(?:/\\.)+(?:/|\\z)}{/}g;                # xx/././xx -> xx/xx\n    $path =~ s|^(?:\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(?:\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\z|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n*canonpath = \\&_pp_canonpath unless defined &canonpath;\n\nsub _pp_catdir {\n    my $self = shift;\n\n    $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'\n}\n*catdir = \\&_pp_catdir unless defined &catdir;\n\nsub _pp_catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n*catfile = \\&_pp_catfile unless defined &catfile;\n\nsub curdir { '.' }\nuse constant _fn_curdir => \".\";\n\nsub devnull { '/dev/null' }\nuse constant _fn_devnull => \"/dev/null\";\n\nsub rootdir { '/' }\nuse constant _fn_rootdir => \"/\";\n\nmy ($tmpdir, %tmpenv);\n# Cache and return the calculated tmpdir, recording which env vars\n# determined it.\nsub _cache_tmpdir {\n    @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};\n    return $tmpdir = $_[1];\n}\n# Retrieve the cached tmpdir, checking first whether relevant env vars have\n# changed and invalidated the cache.\nsub _cached_tmpdir {\n    shift;\n    local $^W;\n    return if grep $ENV{$_} ne $tmpenv{$_}, @_;\n    return $tmpdir;\n}\nsub _tmpdir {\n    my $self = shift;\n    my @dirlist = @_;\n    my $taint = do { no strict 'refs'; ${\"\\cTAINT\"} };\n    if ($taint) { # Check for taint mode on perl >= 5.8.0\n\trequire Scalar::Util;\n\t@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n    }\n    elsif ($] < 5.007) { # No ${^TAINT} before 5.8\n\t@dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;\n    }\n    \n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    if ( !$self->file_name_is_absolute($tmpdir) ) {\n        # See [perl #120593] for the full details\n        # If possible, return a full path, rather than '.' or 'lib', but\n        # jump through some hoops to avoid returning a tainted value.\n        ($tmpdir) = grep {\n            $taint     ? ! Scalar::Util::tainted($_) :\n            $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1\n        } $self->rel2abs($tmpdir), $tmpdir;\n    }\n    return $tmpdir;\n}\n\nsub tmpdir {\n    my $cached = $_[0]->_cached_tmpdir('TMPDIR');\n    return $cached if defined $cached;\n    $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" ), 'TMPDIR');\n}\n\nsub updir { '..' }\nuse constant _fn_updir => \"..\";\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\z/s, @_);\n}\n\nsub case_tolerant { 0 }\nuse constant _fn_case_tolerant => 0;\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(':', $ENV{PATH});\n    foreach (@path) { $_ = '.' if $_ eq '' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = ('','','');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\z )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne ''                && \n         $file ne ''                     && \n         substr( $directory, -1 ) ne '/' && \n         substr( $file, 0, 1 ) ne '/' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n    $base = $self->_cwd() unless defined $base and length $base;\n\n    ($path, $base) = map $self->canonpath($_), $path, $base;\n\n    my $path_directories;\n    my $base_directories;\n\n    if (grep $self->file_name_is_absolute($_), $path, $base) {\n\t($path, $base) = map $self->rel2abs($_), $path, $base;\n\n\tmy ($path_volume) = $self->splitpath($path, 1);\n\tmy ($base_volume) = $self->splitpath($base, 1);\n\n\t# Can't relativize across volumes\n\treturn $path unless $path_volume eq $base_volume;\n\n\t$path_directories = ($self->splitpath($path, 1))[1];\n\t$base_directories = ($self->splitpath($base, 1))[1];\n\n\t# For UNC paths, the user might give a volume like //foo/bar that\n\t# strictly speaking has no directory portion.  Treat it as if it\n\t# had the root directory for that volume.\n\tif (!length($base_directories) and $self->file_name_is_absolute($base)) {\n\t    $base_directories = $self->rootdir;\n\t}\n    }\n    else {\n\tmy $wd= ($self->splitpath($self->_cwd(), 1))[1];\n\t$path_directories = $self->catdir($wd, $path);\n\t$base_directories = $self->catdir($wd, $base);\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path_directories );\n    my @basechunks = $self->splitdir( $base_directories );\n\n    if ($base_directories eq $self->rootdir) {\n      return $self->curdir if $path_directories eq $self->rootdir;\n      shift @pathchunks;\n      return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );\n    }\n\n    my @common;\n    while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {\n        push @common, shift @pathchunks ;\n        shift @basechunks ;\n    }\n    return $self->curdir unless @pathchunks || @basechunks;\n\n    # @basechunks now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  If there\n    # are updir components, we must descend into the corresponding directories\n    # (this only works if they are no symlinks).\n    my @reverse_base;\n    while( defined(my $dir= shift @basechunks) ) {\n\tif( $dir ne $self->updir ) {\n\t    unshift @reverse_base, $self->updir;\n\t    push @common, $dir;\n\t}\n\telsif( @common ) {\n\t    if( @reverse_base && $reverse_base[0] eq $self->updir ) {\n\t\tshift @reverse_base;\n\t\tpop @common;\n\t    }\n\t    else {\n\t\tunshift @reverse_base, pop @common;\n\t    }\n\t}\n    }\n    my $result_dirs = $self->catdir( @reverse_base, @pathchunks );\n    return $self->canonpath( $self->catpath('', $result_dirs, '') );\n}\n\nsub _same {\n  $_[1] eq $_[2];\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq '' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n     ", 8192) = 8192
13887 stat64("/etc/perl/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/constant.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/constant.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/constant.pm", {st_dev=makedev(8, 1), st_ino=923482, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=16, st_size=5458, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/constant.pm", O_RDONLY|O_LARGEFILE) = 6
13887 ioctl(6, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe1c8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(6, 0, [0], SEEK_CUR)      = 0
13887 read(6, "package constant;\nuse 5.008;\nuse strict;\nuse warnings::register;\n\nuse vars qw($VERSION %declared);\n$VERSION = '1.31';\n\n#=======================================================================\n\n# Some names are evil choices.\nmy %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };\n$keywords{UNITCHECK}++ if $] > 5.009;\n\nmy %forced_into_main = map +($_, 1),\n    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };\n\nmy %forbidden = (%keywords, %forced_into_main);\n\nmy $normal_constant_name = qr/^_?[^\\W_0-9]\\w*\\z/;\nmy $tolerable = qr/^[A-Za-z_]\\w*\\z/;\nmy $boolean = qr/^[01]?\\z/;\n\nBEGIN {\n    # We'd like to do use constant _CAN_PCS => $] > 5.009002\n    # but that's a bit tricky before we load the constant module :-)\n    # By doing this, we save 1 run time check for *every* call to import.\n    my $const = $] > 5.009002;\n    my $downgrade = $] < 5.015004; # && $] >= 5.008\n    my $constarray = exists &_make_const;\n    if ($const) {\n\tInternals::SvREADONLY($const, 1);\n\tInternals::SvREADONLY($downgrade, 1);\n\t$constant::{_CAN_PCS}   = \\$const;\n\t$constant::{_DOWNGRADE} = \\$downgrade;\n\t$constant::{_CAN_PCS_FOR_ARRAY} = \\$constarray;\n    }\n    else {\n\tno strict 'refs';\n\t*{\"_CAN_PCS\"}   = sub () {$const};\n\t*{\"_DOWNGRADE\"} = sub () { $downgrade };\n\t*{\"_CAN_PCS_FOR_ARRAY\"} = sub () { $constarray };\n    }\n}\n\n#=======================================================================\n# import() - import symbols into user's namespace\n#\n# What we actually do is define a function in the caller's namespace\n# which returns the value. The function we create will normally\n# be inlined as a constant, thereby avoiding further sub calling \n# overhead.\n#=======================================================================\nsub import {\n    my $class = shift;\n    return unless @_;\t\t\t# Ignore 'use constant;'\n    my $constants;\n    my $multiple  = ref $_[0];\n    my $pkg = caller;\n    my $flush_mro;\n    my $symtab;\n\n    if (_CAN_PCS) {\n\tno strict 'refs';\n\t$symtab = \\%{$pkg . '::'};\n    };\n\n    if ( $multiple ) {\n\tif (ref $_[0] ne 'HASH') {\n\t    require Carp;\n\t    Carp::croak(\"Invalid reference type '\".ref(shift).\"' not 'HASH'\");\n\t}\n\t$constants = shift;\n    } else {\n\tunless (defined $_[0]) {\n\t    require Carp;\n\t    Carp::croak(\"Can't use undef as constant name\");\n\t}\n\t$constants->{+shift} = undef;\n    }\n\n    foreach my $name ( keys %$constants ) {\n\t# Normal constant name\n\tif ($name =~ $normal_constant_name and !$forbidden{$name}) {\n\t    # Everything is okay\n\n\t# Name forced into main, but we're not in main. Fatal.\n\t} elsif ($forced_into_main{$name} and $pkg ne 'main') {\n\t    require Carp;\n\t    Carp::croak(\"Constant name '$name' is forced into main::\");\n\n\t# Starts with double underscore. Fatal.\n\t} elsif ($name =~ /^__/) {\n\t    require Carp;\n\t    Carp::croak(\"Constant name '$name' begins with '__'\");\n\n\t# Maybe the name is tolerable\n\t} elsif ($name =~ $tolerable) {\n\t    # Then we'll warn only if you've asked for warnings\n\t    if (warnings::enabled()) {\n\t\tif ($keywords{$name}) {\n\t\t    warnings::warn(\"Constant name '$name' is a Perl keyword\");\n\t\t} elsif ($forced_into_main{$name}) {\n\t\t    warnings::warn(\"Constant name '$name' is \" .\n\t\t\t\"forced into package main::\");\n\t\t}\n\t    }\n\n\t# Looks like a boolean\n\t# use constant FRED == fred;\n\t} elsif ($name =~ $boolean) {\n            require Carp;\n\t    if (@_) {\n\t\tCarp::croak(\"Constant name '$name' is invalid\");\n\t    } else {\n\t\tCarp::croak(\"Constant name looks like boolean value\");\n\t    }\n\n\t} else {\n\t   # Must have bad characters\n            require Carp;\n\t    Carp::croak(\"Constant name '$name' has invalid characters\");\n\t}\n\n\t{\n\t    no strict 'refs';\n\t    my $full_name = \"${pkg}::$name\";\n\t    $declared{$full_name}++;\n\t    if ($multiple || @_ == 1) {\n\t\tmy $scalar = $multiple ? $constants->{$name} : $_[0];\n\n\t\tif (_DOWNGRADE) { # for 5.8 to 5.14\n\t\t    # Work around perl bug #31991: Sub names (actually glob\n\t\t    # names in general) ignore the UTF8 flag. So we have to\n\t\t    # turn it off to get the \"right\" symbol table entry.\n\t\t    utf8::is_utf8 $name and utf8::encode $name;\n\t\t}\n\n\t\t# The constant serves to optimise this entire block out on\n\t\t# 5.8 and earlier.\n\t\tif (_CAN_PCS) {\n\t\t    # Use a reference as a proxy for a constant subroutine.\n\t\t    # If this is not a glob yet, it saves space.  If it is\n\t\t    # a glob, we must still create it this way to get the\n\t\t    # right internal flags set, as constants are distinct\n\t\t    # from subroutines created with sub(){...}.\n\t\t    # The check in Perl_ck_rvconst knows that inlinable\n\t\t    # constants from cv_const_sv are read only. So we have to:\n\t\t    Internals::SvREADONLY($scalar, 1);\n\t\t    if ($symtab && !exists $symtab->{$name}) {\n\t\t\t$symtab->{$name} = \\$scalar;\n\t\t\t++$flush_mro;\n\t\t    }\n\t\t    else {\n\t\t\tlocal $constant::{_dummy} = \\$scalar;\n\t\t\t*$full_name = \\&{\"_dummy\"};\n\t\t    }\n\t\t} else {\n\t\t    *$full_name = sub () { $scalar };\n\t\t}\n\t    } elsif (@_) {\n\t\tmy @list = @_;\n\t\tif (_CAN_PCS_FOR_ARRAY) {\n\t\t    _make_const($list[$_]) for 0..$#list;\n\t\t    _make_const(@list);\n\t\t    if ($symtab && !exists $symtab->{$name}) {\n\t\t\t$symtab->{$name} = \\@list;\n\t\t\t$flush_mro++;\n\t\t    }\n\t\t    else {\n\t\t\tlocal $constant::{_dummy} = \\@list;\n\t\t\t*$full_name = \\&{\"_dummy\"};\n\t\t    }\n\t\t}\n\t\telse { *$full_name = sub () { @list }; }\n\t    } else {\n\t\t*$full_name = sub () { };\n\t    }\n\t}\n    }\n    # Flush the cache exactly once if we make any direct symbol table changes.\n    mro::method_changed_in($pkg) if _CAN_PCS && $flush_mro;\n}\n\n1;\n\n__END__\n\n", 8192) = 5458
13887 brk(0x82bb000)                    = 0x82bb000
13887 brk(0x82dd000)                    = 0x82dd000
13887 brk(0x82ff000)                    = 0x82ff000
13887 brk(0x8320000)                    = 0x8320000
13887 brk(0x8342000)                    = 0x8342000
13887 _llseek(6, 5457, [5457], SEEK_SET) = 0
13887 _llseek(6, 0, [5457], SEEK_CUR)   = 0
13887 close(6)                          = 0
13887 read(5, "   }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::getcwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n    pop @dirs if @dirs && $dirs[-1] eq '';\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 8192) = 1507
13887 read(5, "", 8192)                 = 0
13887 close(5)                          = 0
13887 stat64("/etc/perl/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/XSLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/XSLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/XSLoader.pm", {st_dev=makedev(8, 1), st_ino=958537, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=2886, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.17\";\n\n#use strict;\n\npackage DynaLoader;\n\n# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    my ($module, $modlibname) = caller();\n\n    if (@_) {\n        $module = $_[0];\n    } else {\n        $_[0] = $module;\n    }\n\n    # work with static linking too\n    my $boots = \"$module\\::bootstrap\";\n    goto &$boots if defined &$boots;\n\n    goto \\&XSLoader::bootstrap_inherit unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join('/',@modparts);\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;    # Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.so\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs 'beside' the library\n\n    if (-s $bs) { # only read file if it's not empty\n#       print STDERR \"BS: $bs ($^O, $dlsrc)\\n\" if $dl_debug;\n        eval { do $bs; };\n        warn \"$bs: $@\\n\" if $@;\n    }\n\n    goto \\&XSLoader::bootstrap_inherit if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can't load '$file' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can't find '$bootname' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub($boots, $boot_symbol_ref, $file);\n\n    # See comment block above\n    push(@DynaLoader::dl_shared_objects, $file); # record files loaded\n    return &$xs(@_);\n}\n\nsub bootstrap_inherit {\n    require DynaLoader;\n    goto \\&DynaLoader::bootstrap_inherit;\n}\n\n1;\n\n__END__\n\n", 8192) = 2886
13887 _llseek(5, 2885, [2885], SEEK_SET) = 0
13887 _llseek(5, 0, [2885], SEEK_CUR)   = 0
13887 close(5)                          = 0
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec/auto/Cwd/Cwd.bs", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/File/Spec/auto/Cwd/Cwd.so", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/DynaLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/DynaLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/DynaLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/DynaLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/DynaLoader.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/DynaLoader.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/DynaLoader.pm", {st_dev=makedev(8, 1), st_ino=658697, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=24, st_size=10748, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/DynaLoader.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "# Generated from DynaLoader_pm.PL\n\npackage DynaLoader;\n\n#   And Gandalf said: 'Many folk like to know beforehand what is to\n#   be set on the table; but those who have laboured to prepare the\n#   feast like to keep their secret; for wonder makes the words of\n#   praise louder.'\n\n#   (Quote from Tolkien suggested by Anno Siegel.)\n#\n# See pod text at end of file for documentation.\n# See also ext/DynaLoader/README in source tree for other information.\n#\n# Tim.Bunce@ig.co.uk, August 1994\n\nBEGIN {\n    $VERSION = '1.25';\n}\n\nuse Config;\n\n# enable debug/trace messages from DynaLoader perl code\n$dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n#\n# Flags to alter dl_load_file behaviour.  Assigned bits:\n#   0x01  make symbols available for linking later dl_load_file's.\n#         (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))\n#         (ignored under VMS; effect is built-in to image linking)\n#         (ignored under Android; the linker always uses RTLD_LOCAL)\n#\n# This is called as a class method $module->dl_load_flags.  The\n# definition here will be inherited and result on \"default\" loading\n# behaviour unless a sub-class of DynaLoader defines its own version.\n#\n\nsub dl_load_flags { 0x00 }\n\n($dl_dlext, $dl_so, $dlsrc) = @Config::Config{qw(dlext so dlsrc)};\n\n$do_expand = 0;\n\n@dl_require_symbols = ();       # names of symbols we need\n@dl_resolve_using   = ();       # names of files to link with\n@dl_library_path    = ();       # path to look for files\n\n#XSLoader.pm may have added elements before we were required\n#@dl_shared_objects  = ();       # shared objects for symbols we have \n#@dl_librefs         = ();       # things we have loaded\n#@dl_modules         = ();       # Modules we have loaded\n\n# This is a fix to support DLD's unfortunate desire to relink -lc\n@dl_resolve_using = dl_findfile('-lc') if $dlsrc eq \"dl_dld.xs\";\n\n# Initialise @dl_library_path with the 'standard' library path\n# for this platform as determined by Configure.\n\npush(@dl_library_path, split(' ', $Config::Config{libpth}));\n\nmy $ldlibpthname         = $Config::Config{ldlibpthname};\nmy $ldlibpthname_defined = defined $Config::Config{ldlibpthname};\nmy $pthsep               = $Config::Config{path_sep};\n\n# Add to @dl_library_path any extra directories we can gather from environment\n# during runtime.\n\nif ($ldlibpthname_defined &&\n    exists $ENV{$ldlibpthname}) {\n    push(@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));\n}\n\n# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.\n\nif ($ldlibpthname_defined &&\n    $ldlibpthname ne 'LD_LIBRARY_PATH' &&\n    exists $ENV{LD_LIBRARY_PATH}) {\n    push(@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));\n}\n\n# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\n\nif ($dl_debug) {\n    print STDERR \"DynaLoader.pm loaded (@INC, @dl_library_path)\\n\";\n    print STDERR \"DynaLoader not linked into this perl\\n\"\n\t    unless defined(&boot_DynaLoader);\n}\n\n1; # End of main code\n\nsub croak   { require Carp; Carp::croak(@_)   }\n\nsub bootstrap_inherit {\n    my $module = $_[0];\n    local *isa = *{\"$module\\::ISA\"};\n    local @isa = (@isa, 'DynaLoader');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    bootstrap(@_);\n}\n\nsub bootstrap {\n    # use local vars to enable $module.bs script to edit values\n    local(@args) = @_;\n    local($module) = $args[0];\n    local(@dirs, $file);\n\n    unless ($module) {\n\trequire Carp;\n\tCarp::confess(\"Usage: DynaLoader::bootstrap(module)\");\n    }\n\n    # A common error on platforms which don't support dynamic loading.\n    # Since it's fatal and potentially confusing we give a detailed message.\n    croak(\"Can't load module $module, dynamic loading not available in this perl.\\n\".\n\t\"  (You may need to build a new perl executable which either supports\\n\".\n\t\"  dynamic loading or has the $module module statically linked into it.)\\n\")\n\tunless defined(&dl_load_file);\n\n    \n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    # Some systems have restrictions on files names for DLL's etc.\n    # mod2fname returns appropriate file base name (typically truncated)\n    # It may also edit @modparts if required.\n    $modfname = &mod2fname(\\@modparts) if defined &mod2fname;\n\n    \n\n    my $modpname = join('/',@modparts);\n\n    print STDERR \"DynaLoader::bootstrap for $module \",\n\t\t       \"(auto/$modpname/$modfname.$dl_dlext)\\n\"\n\tif $dl_debug;\n\n    foreach (@INC) {\n\t\n\t    my $dir = \"$_/auto/$modpname\";\n\t\n\tnext unless -d $dir; # skip over uninteresting directories\n\t\n\t# check for common cases to avoid autoload of dl_findfile\n        my $try = \"$dir/$modfname.$dl_dlext\";\n\tlast if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);\n\t\n\t# no luck here, save dir for possible later dl_findfile search\n\tpush @dirs, $dir;\n    }\n    # last resort, let dl_findfile have a go in all known locations\n    $file = dl_findfile(map(\"-L$_\",@dirs,@INC), $modfname) unless $file;\n\n    croak(\"Can't locate loadable object for module $module in \\@INC (\\@INC contains: @INC)\")\n\tunless $file;\t# wording similar to error from 'require'\n\n    \n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @dl_require_symbols = ($bootname);\n\n    # Execute optional '.bootstrap' perl script for this module.\n    # The .bs file can be used to configure @dl_resolve_using etc to\n    # match the needs of the individual module on this architecture.\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs 'beside' the library\n    if (-s $bs) { # only read file if it's not empty\n        print STDERR \"BS: $bs ($^O, $dlsrc)\\n\" if $dl_debug;\n        eval { do $bs; };\n        warn \"$bs: $@\\n\" if $@;\n    }\n\n    my $boot_symbol_ref;\n\n    \n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $flags = $module->dl_load_flags;\n    \n    my $libref = dl_load_file($file, $flags) or\n\tcroak(\"Can't load '$file' for module $module: \".dl_error());\n\n    push(@dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n\trequire Carp;\n\tCarp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or\n         croak(\"Can't find '$bootname' symbol in $file\\n\");\n\n    push(@dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n\n\tpush(@dl_shared_objects, $file); # record files loaded\n\n    &$xs(@args);\n}\n\nsub dl_findfile {\n    # Read ext/DynaLoader/DynaLoader.doc for detailed information.\n    # This function does not automatically consider the architecture\n    # or the perl library auto directories.\n    my (@args) = @_;\n    my (@dirs,  $dir);   # which directories to search\n    my (@found);         # full paths to real files we have found\n    #my $dl_ext= 'so'; # $Config::Config{'dlext'} suffix for perl extensions\n    #my $dl_so = 'so'; # $Config::Config{'so'} suffix for shared libraries\n\n    print STDERR \"dl_findfile(@args)\\n\" if $dl_debug;\n\n    # accumulate directories but process files as they appear\n    arg: foreach(@args) {\n        #  Special fast case: full filepath requires no search\n\t\n\t\n        if (m:/: && -f $_) {\n\t    push(@found,$_);\n\t    last arg unless wantarray;\n\t    next;\n\t}\n\t\n\n        # Deal with directories first:\n        #  Using a -L prefix is the preferred option (faster and more robust)\n        if (m:^-L:) { s/^-L//; push(@dirs, $_); next; }\n\n        #  Otherwise we try to try to spot directories by a heuristic\n        #  (this is a more complicated issue than it first appears)\n        if (m:/: && -d $_) {   push(@dir", 8192) = 8192
13887 stat64("/etc/perl/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/Config.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Config.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Config.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Config.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Config.pm", 0xbfffe3fc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Config.pmc", 0xbfffe49c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Config.pm", {st_dev=makedev(8, 1), st_ino=655507, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=3330, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/Config.pm", O_RDONLY|O_LARGEFILE) = 6
13887 ioctl(6, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe1c8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(6, 0, [0], SEEK_CUR)      = 0
13887 read(6, "# This file was created by configpm when Perl was built. Any changes\n# made to this file will be lost the next time perl is built.\n\n# for a description of the variables, please have a look at the\n# Glossary file, as written in the Porting folder, or use the url:\n# http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary\n\npackage Config;\nuse strict;\nuse warnings;\nuse vars '%Config', '$VERSION';\n\n$VERSION = \"5.020002\";\n\n# Skip @Config::EXPORT because it only contains %Config, which we special\n# case below as it's not a function. @Config::EXPORT won't change in the\n# lifetime of Perl 5.\nmy %Export_Cache = (myconfig => 1, config_sh => 1, config_vars => 1,\n\t\t    config_re => 1, compile_date => 1, local_patches => 1,\n\t\t    bincompat_options => 1, non_bincompat_options => 1,\n\t\t    header_files => 1);\n\n@Config::EXPORT = qw(%Config);\n@Config::EXPORT_OK = keys %Export_Cache;\n\n# Need to stub all the functions to make code such as print Config::config_sh\n# keep working\n\nsub bincompat_options;\nsub compile_date;\nsub config_re;\nsub config_sh;\nsub config_vars;\nsub header_files;\nsub local_patches;\nsub myconfig;\nsub non_bincompat_options;\n\n# Define our own import method to avoid pulling in the full Exporter:\nsub import {\n    shift;\n    @_ = @Config::EXPORT unless @_;\n\n    my @funcs = grep $_ ne '%Config', @_;\n    my $export_Config = @funcs < @_ ? 1 : 0;\n\n    no strict 'refs';\n    my $callpkg = caller(0);\n    foreach my $func (@funcs) {\n\tdie qq{\"$func\" is not exported by the Config module\\n}\n\t    unless $Export_Cache{$func};\n\t*{$callpkg.'::'.$func} = \\&{$func};\n    }\n\n    *{\"$callpkg\\::Config\"} = \\%Config if $export_Config;\n    return;\n}\n\ndie \"$0: Perl lib version (5.20.2) doesn't match executable '$^X' version ($])\"\n    unless $^V;\n\n$^V eq 5.20.2\n    or die sprintf \"%s: Perl lib version (5.20.2) doesn't match executable '$^X' version (%vd)\", $0, $^V;\n\nsub FETCH {\n    my($self, $key) = @_;\n\n    # check for cached value (which may be undef so we use exists not defined)\n    return exists $self->{$key} ? $self->{$key} : $self->fetch_string($key);\n}\n\nsub TIEHASH {\n    bless $_[1], $_[0];\n}\n\nsub DESTROY { }\n\nsub AUTOLOAD {\n    require 'Config_heavy.pl';\n    goto \\&launcher unless $Config::AUTOLOAD =~ /launcher$/;\n    die \"&Config::AUTOLOAD failed on $Config::AUTOLOAD\";\n}\n\n# tie returns the object, so the value returned to require will be true.\ntie %Config, 'Config', {\n    archlibexp => '/usr/lib/i386-linux-gnu/perl/5.20',\n    archname => 'i686-linux-gnu-thread-multi-64int',\n    cc => 'cc',\n    d_readlink => 'define',\n    d_symlink => 'define',\n    dlext => 'so',\n    dlsrc => 'dl_dlopen.xs',\n    dont_use_nlink => undef,\n    exe_ext => '',\n    inc_version_list => '5.20.1 5.20.0',\n    intsize => '4',\n    ldlibpthname => 'LD_LIBRARY_PATH',\n    libpth => '/usr/local/lib /usr/lib/gcc/i686-linux-gnu/4.9/include-fixed /usr/include/i386-linux-gnu /usr/lib /lib/i386-linux-gnu /lib/../lib /usr/lib/i386-linux-gnu /usr/lib/../lib /lib',\n    osname => 'linux',\n    osvers => '3.13.0-76-generic',\n    path_sep => ':',\n    privlibexp => '/usr/share/perl/5.20',\n    scriptdir => '/usr/bin',\n    sitearchexp => '/usr/local/lib/i386-linux-gnu/perl/5.20.2',\n    sitelibexp => '/usr/local/share/perl/5.20.2',\n    so => 'so',\n    useithreads => 'define',\n    usevendorprefix => 'define',\n    version => '5.20.2',\n};\n", 8192) = 3330
13887 read(6, "", 8192)                 = 0
13887 close(6)                          = 0
13887 read(5, "s, $_); next; }\n\n\t\n\n        #  Only files should get this far...\n        my(@names, $name);    # what filenames to look for\n        if (m:-l: ) {          # convert -lname to appropriate library name\n            s/-l//;\n            push(@names,\"lib$_.$dl_so\");\n            push(@names,\"lib$_.a\");\n        } else {                # Umm, a bare name. Try various alternatives:\n            # these should be ordered with the most likely first\n            push(@names,\"$_.$dl_dlext\")    unless m/\\.$dl_dlext$/o;\n            push(@names,\"$_.$dl_so\")     unless m/\\.$dl_so$/o;\n\t    \n            push(@names,\"lib$_.$dl_so\")  unless m:/:;\n            push(@names,\"$_.a\")          if !m/\\.a$/ and $dlsrc eq \"dl_dld.xs\";\n            push(@names, $_);\n        }\n\tmy $dirsep = '/';\n\t\n        foreach $dir (@dirs, @dl_library_path) {\n            next unless -d $dir;\n\t    \n            foreach $name (@names) {\n\t\tmy($file) = \"$dir$dirsep$name\";\n                print STDERR \" checking in $dir for $name\\n\" if $dl_debug;\n\t\t$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);\n\t\t#$file = _check_file($file);\n\t\tif ($file) {\n                    push(@found, $file);\n                    next arg; # no need to look any further\n                }\n            }\n        }\n    }\n    if ($dl_debug) {\n        foreach(@dirs) {\n            print STDERR \" dl_findfile ignored non-existent directory: $_\\n\" unless -d $_;\n        }\n        print STDERR \"dl_findfile found: @found\\n\";\n    }\n    return $found[0] unless wantarray;\n    @found;\n}\n\nsub dl_expandspec {\n    my($spec) = @_;\n    # Optional function invoked if DynaLoader.pm sets $do_expand.\n    # Most systems do not require or use this function.\n    # Some systems may implement it in the dl_*.xs file in which case\n    # this Perl version should be excluded at build time.\n\n    # This function is designed to deal with systems which treat some\n    # 'filenames' in a special way. For example VMS 'Logical Names'\n    # (something like unix environment variables - but different).\n    # This function should recognise such names and expand them into\n    # full file paths.\n    # Must return undef if $spec is invalid or file does not exist.\n\n    my $file = $spec; # default output to input\n\n\treturn undef unless -f $file;\n    print STDERR \"dl_expandspec($spec) => $file\\n\" if $dl_debug;\n    $file;\n}\n\nsub dl_find_symbol_anywhere\n{\n    my $sym = shift;\n    my $libref;\n    foreach $libref (@dl_librefs) {\n\tmy $symref = dl_find_symbol($libref,$sym);\n\treturn $symref if $symref;\n    }\n    return undef;\n}\n\n__END__\n\n", 8192) = 2556
13887 _llseek(5, 10747, [10747], SEEK_SET) = 0
13887 _llseek(5, 0, [10747], SEEK_CUR)  = 0
13887 close(5)                          = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 stat64("/etc/perl/auto/Cwd", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/auto/Cwd", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/auto/Cwd", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/auto/Cwd", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/auto/Cwd", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/Cwd", {st_dev=makedev(8, 1), st_ino=660171, st_mode=S_IFDIR|0755, st_nlink=2, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=4096, st_atime=2016/11/06-20:51:25, st_mtime=2016/02/02-19:10:26, st_ctime=2016/02/02-19:10:26}) = 0
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/Cwd/Cwd.so", {st_dev=makedev(8, 1), st_ino=656071, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=40, st_size=17852, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:44, st_ctime=2016/02/02-19:10:26}) = 0
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/Cwd/Cwd.bs", 0x8214164) = -1 ENOENT (No such file or directory)
13887 futex(0xb7fc0058, FUTEX_WAKE_PRIVATE, 2147483647) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/auto/Cwd/Cwd.so", O_RDONLY|O_CLOEXEC) = 5
13887 read(5, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\320\f\0\0004\0\0\0\254A\0\0\0\0\0\0004\0 \0\7\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0300\0\0\0300\0\0\5\0\0\0\0\20\0\0\1\0\0\0\0?\0\0\0O\0\0\0O\0\0\270\1\0\0\274\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\f?\0\0\fO\0\0\fO\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0P\345tdd&\0\0d&\0\0d&\0\0|\0\0\0|\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\0?\0\0\0O\0\0\0O\0\0\0\1\0\0\0\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\342\264\232\215\276z\24\350\20\332X\346{x\336^\340\335\334O\3\0\0\0-\0\0\0\2\0\0\0\6\0\0\0\210\0h\1\0\304@\t-\0\0\0/\0\0\0001\0\0\0BE\325\354\273\343\222|\330qX\34\271\215\361\16\352\323\357\16\327\34\274X\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0\31\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\366\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\241\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\7\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0\202\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0o\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
13887 fstat64(5, {st_dev=makedev(8, 1), st_ino=656071, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=40, st_size=17852, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:44, st_ctime=2016/02/02-19:10:26}) = 0
13887 mmap2(NULL, 20668, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0xb7fd3000
13887 mmap2(0xb7fd7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x3000) = 0xb7fd7000
13887 close(5)                          = 0
13887 mprotect(0xb7fd7000, 4096, PROT_READ) = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 read(4, "   utime($atime, $mtime, $to);\n            unlink($from)   or die;\n        };\n        return 1 unless $@;\n    }\n    ($sts,$ossts) = ($! + 0, $^E + 0);\n\n    ($tosz2,$tomt2) = ((stat($to))[7,9],0,0) if defined $tomt1;\n    unlink($to) if !defined($tomt1) or $tomt1 != $tomt2 or $tosz1 != $tosz2;\n    ($!,$^E) = ($sts,$ossts);\n    return 0;\n}\n\nsub move { _move(@_,\\&copy); }\nsub mv   { _move(@_,\\&cp);   }\n\n# &syscopy is an XSUB under OS/2\nunless (defined &syscopy) {\n    if ($^O eq 'VMS') {\n\t*syscopy = \\&rmscopy;\n    } elsif ($^O eq 'MSWin32' && defined &DynaLoader::boot_DynaLoader) {\n\t# Win32::CopyFile() fill only work if we can load Win32.xs\n\t*syscopy = sub {\n\t    return 0 unless @_ == 2;\n\t    return Win32::CopyFile(@_, 1);\n\t};\n    } else {\n\t$Syscopy_is_copy = 1;\n\t*syscopy = \\&copy;\n    }\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nFile::Copy - Copy files or filehandles\n\n=head1 SYNOPSIS\n\n\tuse File::Copy;\n\n\tcopy(\"sourcefile\",\"destinationfile\") or die \"Copy failed: $!\";\n\tcopy(\"Copy.pm\",\\*STDOUT);\n\tmove(\"/dev1/sourcefile\",\"/dev2/destinationfile\");\n\n\tuse File::Copy \"cp\";\n\n\t$n = FileHandle->new(\"/a/file\",\"r\");\n\tcp($n,\"x\");\n\n=head1 DESCRIPTION\n\nThe File::Copy module provides two basic functions, C<copy> and\nC<move>, which are useful for getting the contents of a file from\none place to another.\n\n=over 4\n\n=item copy\nX<copy> X<cp>\n\nThe C<copy> function takes two\nparameters: a file to copy from and a file to copy to. Either\nargument may be a string, a FileHandle reference or a FileHandle\nglob. Obviously, if the first argument is a filehandle of some\nsort, it will be read from, and if it is a file I<name> it will\nbe opened for reading. Likewise, the second argument will be\nwritten to. If the second argument does not exist but the parent\ndirectory does exist, then it will be created. Trying to copy\na file into a non-existent directory is an error.\nTrying to copy a file on top of itself is also an error.\nC<copy> will not overwrite read-only files.\n\nIf the destination (second argument) already exists and is a directory,\nand the source (first argument) is not a filehandle, then the source\nfile will be copied into the directory specified by the destination,\nusing the same base name as the source file.  It's a failure to have a\nfilehandle as the source when the destination is a directory.\n\nB<Note that passing in\nfiles as handles instead of names may lead to loss of information\non some operating systems; it is recommended that you use file\nnames whenever possible.>  Files are opened in binary mode where\napplicable.  To get a consistent behaviour when copying from a\nfilehandle to a file, use C<binmode> on the filehandle.\n\nAn optional third parameter can be used to specify the buffer\nsize used for copying. This is the number of bytes from the\nfirst file, that will be held in memory at any given time, before\nbeing written to the second file. The default buffer size depends\nupon the file, but will generally be the whole file (up to 2MB), or\n1k for filehandles that do not reference files (eg. sockets).\n\nYou may use the syntax C<use File::Copy \"cp\"> to get at the C<cp>\nalias for this function. The syntax is I<exactly> the same.  The\nbehavior is nearly the same as well: as of version 2.15, C<cp> will\npreserve the source file's permission bits like the shell utility\nC<cp(1)> would do, while C<copy> uses the default permissions for the\ntarget file (which may depend on the process' C<umask>, file\nownership, inherited ACLs, etc.).  If an error occurs in setting\npermissions, C<cp> will return 0, regardless of whether the file was\nsuccessfully copied.\n\n=item move\nX<move> X<mv> X<rename>\n\nThe C<move> function also takes two parameters: the current name\nand the intended name of the file to be moved.  If the destination\nalready exists and is a directory, and the source is not a\ndirectory, then the source file will be renamed into the directory\nspecified by the destination.\n\nIf possible, move() will simply rename the file.  Otherwise, it copies\nthe file to the new location and deletes the original.  If an error occurs\nduring this copy-and-delete process, you may be left with a (possibly partial)\ncopy of the file under the destination name.\n\nYou may use the C<mv> alias for this function in the same way that\nyou may use the C<cp> alias for C<copy>.\n\n=item syscopy\nX<syscopy>\n\nFile::Copy also provides the C<syscopy> routine, which copies the\nfile specified in the first parameter to the file specified in the\nsecond parameter, preserving OS-specific attributes and file\nstructure.  For Unix systems, this is equivalent to the simple\nC<copy> routine, which doesn't preserve OS-specific attributes.  For\nVMS systems, this calls the C<rmscopy> routine (see below).  For OS/2\nsystems, this calls the C<syscopy> XSUB directly. For Win32 systems,\nthis calls C<Win32::CopyFile>.\n\nB<Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)>:\n\nIf both arguments to C<copy> are not file handles,\nthen C<copy> will perform a \"system copy\" of\nthe input file to a new output file, in order to preserve file\nattributes, indexed file structure, I<etc.>  The buffer size\nparameter is ignored.  If either argument to C<copy> is a\nhandle to an opened file, then data is copied using Perl\noperators, and no effort is made to preserve file attributes\nor record structure.\n\nThe system copy routine may also be called directly under VMS and OS/2\nas C<File::Copy::syscopy> (or under VMS as C<File::Copy::rmscopy>, which\nis the routine that does the actual work for syscopy).\n\n=item rmscopy($from,$to[,$date_flag])\nX<rmscopy>\n\nThe first and second arguments may be strings, typeglobs, typeglob\nreferences, or objects inheriting from IO::Handle;\nthey are used in all cases to obtain the\nI<filespec> of the input and output files, respectively.  The\nname and type of the input file are used as defaults for the\noutput file, if necessary.\n\nA new version of the output file is always created, which\ninherits the structure and RMS attributes of the input file,\nexcept for owner and protections (and possibly timestamps;\nsee below).  All data from the input file is copied to the\noutput file; if either of the first two parameters to C<rmscopy>\nis a file handle, its position is unchanged.  (Note that this\nmeans a file handle pointing to the output file will be\nassociated with an old version of that file after C<rmscopy>\nreturns, not the newly created version.)\n\nThe third parameter is an integer flag, which tells C<rmscopy>\nhow to handle timestamps.  If it is E<lt> 0, none of the input file's\ntimestamps are propagated to the output file.  If it is E<gt> 0, then\nit is interpreted as a bitmask: if bit 0 (the LSB) is set, then\ntimestamps other than the revision date are propagated; if bit 1\nis set, the revision date is propagated.  If the third parameter\nto C<rmscopy> is 0, then it behaves much like the DCL COPY command:\nif the name or type of the output file was explicitly specified,\nthen no timestamps are propagated, but if they were taken implicitly\nfrom the input filespec, then all timestamps other than the\nrevision date are propagated.  If this parameter is not supplied,\nit defaults to 0.\n\nLike C<copy>, C<rmscopy> returns 1 on success.  If an error occurs,\nit sets C<$!>, deletes the output file, and returns 0.\n\n=back\n\n=head1 RETURN\n\nAll functions return 1 on success, 0 on failure.\n$! will be set if an error was encountered.\n\n=head1 AUTHOR\n\nFile::Copy was written by Aaron Sherman I<E<lt>ajs@ajs.comE<gt>> in 1995,\nand updated by Charles Bailey I<E<lt>bailey@newman.upenn.eduE<gt>> in 1996.\n\n=cut\n\n", 8192) = 7522
13887 _llseek(4, 9001, [9001], SEEK_SET) = 0
13887 _llseek(4, 0, [9001], SEEK_CUR)   = 0
13887 close(4)                          = 0
13887 stat64("/etc/perl/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/Scalar/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Scalar/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Scalar/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Scalar/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Scalar/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Scalar/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Scalar/Util.pm", {st_dev=makedev(8, 1), st_ino=656049, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=1143, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/Scalar/Util.pm", O_RDONLY|O_LARGEFILE) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffeb68) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 read(4, "# Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n#\n# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>\n\npackage Scalar::Util;\n\nuse strict;\nrequire Exporter;\nrequire List::Util; # List::Util loads the XS\n\nour @ISA       = qw(Exporter);\nour @EXPORT_OK = qw(\n  blessed refaddr reftype weaken unweaken isweak\n\n  dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted\n);\nour $VERSION    = \"1.38\";\n$VERSION   = eval $VERSION;\n\nour @EXPORT_FAIL;\n\nunless (defined &weaken) {\n  push @EXPORT_FAIL, qw(weaken);\n}\nunless (defined &isweak) {\n  push @EXPORT_FAIL, qw(isweak isvstring);\n}\nunless (defined &isvstring) {\n  push @EXPORT_FAIL, qw(isvstring);\n}\n\nsub export_fail {\n  if (grep { /^(?:weaken|isweak)$/ } @_ ) {\n    require Carp;\n    Carp::croak(\"Weak references are not implemented in the version of perl\");\n  }\n\n  if (grep { /^isvstring$/ } @_ ) {\n    require Carp;\n    Carp::croak(\"Vstrings are not implemented in the version of perl\");\n  }\n\n  @_;\n}\n\n1;\n\n__END__\n\n", 8192) = 1143
13887 _llseek(4, 1142, [1142], SEEK_SET) = 0
13887 _llseek(4, 0, [1142], SEEK_CUR)   = 0
13887 close(4)                          = 0
13887 stat64("/etc/perl/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/Exporter.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/Exporter.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/Exporter.pm", {st_dev=makedev(8, 1), st_ino=958534, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=2367, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/Exporter.pm", O_RDONLY|O_LARGEFILE) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffeb68) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 read(4, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict 'refs';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = '5.71';\nour (%Cache);\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my $exports = \\@{\"$pkg\\::EXPORT\"};\n  # But, avoid creating things if they don't exist, which saves a couple of\n  # hundred bytes per package processed.\n  my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \\@{\"$pkg\\::EXPORT_FAIL\"};\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or $fail && @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or $fail and @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp} if not $SIG{__WARN__};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 8192) = 2367
13887 _llseek(4, 2366, [2366], SEEK_SET) = 0
13887 _llseek(4, 0, [2366], SEEK_CUR)   = 0
13887 close(4)                          = 0
13887 stat64("/etc/perl/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/List/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/List/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/List/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/List/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/List/Util.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/List/Util.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/List/Util.pm", {st_dev=makedev(8, 1), st_ino=655616, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=944, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/List/Util.pm", O_RDONLY|O_LARGEFILE) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffeb68) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 read(4, "# Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n#\n# Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>\n\npackage List::Util;\n\nuse strict;\nrequire Exporter;\n\nour @ISA        = qw(Exporter);\nour @EXPORT_OK  = qw(\n  all any first min max minstr maxstr none notall product reduce sum sum0 shuffle\n  pairmap pairgrep pairfirst pairs pairkeys pairvalues\n);\nour $VERSION    = \"1.38\";\nour $XS_VERSION = $VERSION;\n$VERSION    = eval $VERSION;\n\nrequire XSLoader;\nXSLoader::load('List::Util', $XS_VERSION);\n\nsub import\n{\n  my $pkg = caller;\n\n  # (RT88848) Touch the caller's $a and $b, to avoid the warning of\n  #   Name \"main::a\" used only once: possible typo\" warning\n  no strict 'refs';\n  ${\"${pkg}::a\"} = ${\"${pkg}::a\"};\n  ${\"${pkg}::b\"} = ${\"${pkg}::b\"};\n\n  goto &Exporter::import;\n}\n\n1;\n\n__END__\n\n", 8192) = 944
13887 _llseek(4, 943, [943], SEEK_SET)  = 0
13887 _llseek(4, 0, [943], SEEK_CUR)    = 0
13887 close(4)                          = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/List/Util/Util.bs", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/List/Util/Util.so", {st_dev=makedev(8, 1), st_ino=656068, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=88, st_size=42532, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:44, st_ctime=2016/02/02-19:10:26}) = 0
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/auto/List/Util/Util.bs", 0x8214164) = -1 ENOENT (No such file or directory)
13887 open("/usr/lib/i386-linux-gnu/perl/5.20/auto/List/Util/Util.so", O_RDONLY|O_CLOEXEC) = 4
13887 read(4, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0P\23\0\0004\0\0\0\24\242\0\0\0\0\0\0004\0 \0\7\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\217\0\0h\217\0\0\5\0\0\0\0\20\0\0\1\0\0\0\374\236\0\0\374\236\0\0\374\236\0\0$\2\0\0(\2\0\0\6\0\0\0\0\20\0\0\2\0\0\0\10\237\0\0\10\237\0\0\10\237\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0P\345td\320s\0\0\320s\0\0\320s\0\0\4\1\0\0\4\1\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0R\345td\374\236\0\0\374\236\0\0\374\236\0\0\4\1\0\0\4\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\362\266\323<\344\224\351\223\233\336\225\23\315p\34\6\264h\360\206\3\0\0\0I\0\0\0\2\0\0\0\6\0\0\0\211\0!\1\0\304@\tI\0\0\0K\0\0\0N\0\0\0BE\325\354\273\343\222|\20@\336\302\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\3\0\0\0\0\0\0\0\0\0\0\20\0\0\0V\4\0\0\0\0\0\0\0\0\0\0\20\0\0\0\305\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\221\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0\333\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\313\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0\200\2\0\0\0\0\0\0\0\0\0\0\20\0\0\0\7\2\0\0\0\0\0\0\0\0\0\0", 512) = 512
13887 fstat64(4, {st_dev=makedev(8, 1), st_ino=656068, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=88, st_size=42532, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:44, st_ctime=2016/02/02-19:10:26}) = 0
13887 mmap2(NULL, 41252, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 4, 0) = 0xb7fc8000
13887 mmap2(0xb7fd1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 4, 0x9000) = 0xb7fd1000
13887 close(4)                          = 0
13887 mprotect(0xb7fd1000, 4096, PROT_READ) = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 stat64("/etc/perl/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/overload.pm", 0xbfffed9c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/overload.pmc", 0xbfffee3c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/overload.pm", {st_dev=makedev(8, 1), st_ino=958539, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=16, st_size=4462, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/overload.pm", O_RDONLY|O_LARGEFILE) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffeb68) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 read(4, "package overload;\n\nour $VERSION = '1.22';\n\n%ops = (\n    with_assign         => \"+ - * / % ** << >> x .\",\n    assign              => \"+= -= *= /= %= **= <<= >>= x= .=\",\n    num_comparison      => \"< <= >  >= == !=\",\n    '3way_comparison'   => \"<=> cmp\",\n    str_comparison      => \"lt le gt ge eq ne\",\n    binary              => '& &= | |= ^ ^=',\n    unary               => \"neg ! ~\",\n    mutators            => '++ --',\n    func                => \"atan2 cos sin exp abs log sqrt int\",\n    conversion          => 'bool \"\" 0+ qr',\n    iterators           => '<>',\n    filetest            => \"-X\",\n    dereferencing       => '${} @{} %{} &{} *{}',\n    matching            => '~~',\n    special             => 'nomethod fallback =',\n);\n\nmy %ops_seen;\nfor $category (keys %ops) {\n    $ops_seen{$_}++ for (split /\\s+/, $ops{$category});\n}\n\nsub nil {}\n\nsub OVERLOAD {\n  $package = shift;\n  my %arg = @_;\n  my ($sub, $fb);\n  *{$package . \"::((\"} = \\&nil; # Make it findable via fetchmethod.\n  for (keys %arg) {\n    if ($_ eq 'fallback') {\n      for my $sym (*{$package . \"::()\"}) {\n\t*$sym = \\&nil; # Make it findable via fetchmethod.\n\t$$sym = $arg{$_};\n      }\n    } else {\n      warnings::warnif(\"overload arg '$_' is invalid\")\n        unless $ops_seen{$_};\n      $sub = $arg{$_};\n      if (not ref $sub) {\n\t$ {$package . \"::(\" . $_} = $sub;\n\t$sub = \\&nil;\n      }\n      #print STDERR \"Setting '$ {'package'}::\\cO$_' to \\\\&'$sub'.\\n\";\n      *{$package . \"::(\" . $_} = \\&{ $sub };\n    }\n  }\n}\n\nsub import {\n  $package = (caller())[0];\n  # *{$package . \"::OVERLOAD\"} = \\&OVERLOAD;\n  shift;\n  $package->overload::OVERLOAD(@_);\n}\n\nsub unimport {\n  $package = (caller())[0];\n  shift;\n  *{$package . \"::((\"} = \\&nil;\n  for (@_) {\n      warnings::warnif(\"overload arg '$_' is invalid\")\n        unless $ops_seen{$_};\n      delete $ {$package . \"::\"}{$_ eq 'fallback' ? '()' : \"(\" .$_};\n  }\n}\n\nsub Overloaded {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  mycan ($package, '()') || mycan ($package, '((');\n}\n\nsub ov_method {\n  my $globref = shift;\n  return undef unless $globref;\n  my $sub = \\&{*$globref};\n  no overloading;\n  return $sub if !ref $sub or $sub != \\&nil;\n  return shift->can($ {*$globref});\n}\n\nsub OverloadedStringify {\n  my $package = shift;\n  $package = ref $package if ref $package;\n  #$package->can('(\"\"')\n  ov_method mycan($package, '(\"\"'), $package\n    or ov_method mycan($package, '(0+'), $package\n    or ov_method mycan($package, '(bool'), $package\n    or ov_method mycan($package, '(nomethod'), $package;\n}\n\nsub Method {\n  my $package = shift;\n  if(ref $package) {\n    local $@;\n    local $!;\n    require Scalar::Util;\n    $package = Scalar::Util::blessed($package);\n    return undef if !defined $package;\n  }\n  #my $meth = $package->can('(' . shift);\n  ov_method mycan($package, '(' . shift), $package;\n  #return $meth if $meth ne \\&nil;\n  #return $ {*{$meth}};\n}\n\nsub AddrRef {\n  no overloading;\n  \"$_[0]\";\n}\n\n*StrVal = *AddrRef;\n\nsub mycan {\t\t\t\t# Real can would leave stubs.\n  my ($package, $meth) = @_;\n\n  local $@;\n  local $!;\n  require mro;\n\n  my $mro = mro::get_linear_isa($package);\n  foreach my $p (@$mro) {\n    my $fqmeth = $p . q{::} . $meth;\n    return \\*{$fqmeth} if defined &{$fqmeth};\n  }\n\n  return undef;\n}\n\n%constants = (\n\t      'integer'\t  =>  0x1000, # HINT_NEW_INTEGER\n\t      'float'\t  =>  0x2000, # HINT_NEW_FLOAT\n\t      'binary'\t  =>  0x4000, # HINT_NEW_BINARY\n\t      'q'\t  =>  0x8000, # HINT_NEW_STRING\n\t      'qr'\t  => 0x10000, # HINT_NEW_RE\n\t     );\n\nuse warnings::register;\nsub constant {\n  # Arguments: what, sub\n  while (@_) {\n    if (@_ == 1) {\n        warnings::warnif (\"Odd number of arguments for overload::constant\");\n        last;\n    }\n    elsif (!exists $constants {$_ [0]}) {\n        warnings::warnif (\"'$_[0]' is not an overloadable type\");\n    }\n    elsif (!ref $_ [1] || \"$_[1]\" !~ /(^|=)CODE\\(0x[0-9a-f]+\\)$/) {\n        # Can't use C<ref $_[1] eq \"CODE\"> above as code references can be\n        # blessed, and C<ref> would return the package the ref is blessed into.\n        if (warnings::enabled) {\n            $_ [1] = \"undef\" unless defined $_ [1];\n            warnings::warn (\"'$_[1]' is not a code reference\");\n        }\n    }\n    else {\n        $^H{$_[0]} = $_[1];\n        $^H |= $constants{$_[0]};\n    }\n    shift, shift;\n  }\n}\n\nsub remove_constant {\n  # Arguments: what, sub\n  while (@_) {\n    delete $^H{$_[0]};\n    $^H &= ~ $constants{$_[0]};\n    shift, shift;\n  }\n}\n\n1;\n\n__END__\n\n", 8192) = 4462
13887 stat64("/etc/perl/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/etc/perl/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/lib/i386-linux-gnu/perl/5.20.2/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/local/share/perl/5.20.2/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl5/5.20/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl5/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/lib/i386-linux-gnu/perl/5.20/overloading.pm", 0xbfffe8cc) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/overloading.pmc", 0xbfffe96c) = -1 ENOENT (No such file or directory)
13887 stat64("/usr/share/perl/5.20/overloading.pm", {st_dev=makedev(8, 1), st_ino=958540, st_mode=S_IFREG|0644, st_nlink=1, st_uid=0, st_gid=0, st_blksize=4096, st_blocks=8, st_size=964, st_atime=2017/03/20-20:35:36, st_mtime=2016/01/20-17:05:36, st_ctime=2016/02/02-19:10:26}) = 0
13887 open("/usr/share/perl/5.20/overloading.pm", O_RDONLY|O_LARGEFILE) = 5
13887 ioctl(5, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbfffe698) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(5, 0, [0], SEEK_CUR)      = 0
13887 read(5, "package overloading;\nuse warnings;\n\nour $VERSION = '0.02';\n\nmy $HINT_NO_AMAGIC = 0x01000000; # see perl.h\n\nrequire 5.010001;\n\nsub _ops_to_nums {\n    require overload::numbers;\n\n    map { exists $overload::numbers::names{\"($_\"}\n\t? $overload::numbers::names{\"($_\"}\n\t: do { require Carp; Carp::croak(\"'$_' is not a valid overload\") }\n    } @_;\n}\n\nsub import {\n    my ( $class, @ops ) = @_;\n\n    if ( @ops ) {\n\tif ( $^H{overloading} ) {\n\t    vec($^H{overloading} , $_, 1) = 0 for _ops_to_nums(@ops);\n\t}\n\n\tif ( $^H{overloading} !~ /[^\\0]/ ) {\n\t    delete $^H{overloading};\n\t    $^H &= ~$HINT_NO_AMAGIC;\n\t}\n    } else {\n\tdelete $^H{overloading};\n\t$^H &= ~$HINT_NO_AMAGIC;\n    }\n}\n\nsub unimport {\n    my ( $class, @ops ) = @_;\n\n    if ( exists $^H{overloading} or not $^H & $HINT_NO_AMAGIC ) {\n\tif ( @ops ) {\n\t    vec($^H{overloading} ||= '', $_, 1) = 1 for _ops_to_nums(@ops);\n\t} else {\n\t    delete $^H{overloading};\n\t}\n    }\n\n    $^H |= $HINT_NO_AMAGIC;\n}\n\n1;\n__END__\n\n", 8192) = 964
13887 _llseek(5, 963, [963], SEEK_SET)  = 0
13887 _llseek(5, 0, [963], SEEK_CUR)    = 0
13887 close(5)                          = 0
13887 _llseek(4, 4461, [4461], SEEK_SET) = 0
13887 _llseek(4, 0, [4461], SEEK_CUR)   = 0
13887 close(4)                          = 0
13887 getuid32()                        = 1000
13887 geteuid32()                       = 1000
13887 getgid32()                        = 1000
13887 getegid32()                       = 1000
13887 read(3, "", 8192)                 = 0
13887 close(3)                          = 0
13887 stat64("/mnt/c/test.txt", 0x8214164) = -1 ENOENT (No such file or directory)
13887 stat64("/mnt/b/test.txt", {st_dev=makedev(8, 17), st_ino=352, st_mode=S_IFREG|0664, st_nlink=1, st_uid=1000, st_gid=1000, st_blksize=4096, st_blocks=8, st_size=18, st_atime=2017/03/20-20:35:54, st_mtime=2017/03/20-20:35:06, st_ctime=2017/03/20-20:35:06}) = 0
13887 stat64("/mnt/c/test.txt", 0x8214164) = -1 ENOENT (No such file or directory)
13887 open("/mnt/b/test.txt", O_RDONLY|O_LARGEFILE) = 3
13887 ioctl(3, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbffff1d8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(3, 0, [0], SEEK_CUR)      = 0
13887 fstat64(3, {st_dev=makedev(8, 17), st_ino=352, st_mode=S_IFREG|0664, st_nlink=1, st_uid=1000, st_gid=1000, st_blksize=4096, st_blocks=8, st_size=18, st_atime=2017/03/20-20:35:54, st_mtime=2017/03/20-20:35:06, st_ctime=2017/03/20-20:35:06}) = 0
13887 fcntl64(3, F_SETFD, FD_CLOEXEC)   = 0
13887 fstat64(3, {st_dev=makedev(8, 17), st_ino=352, st_mode=S_IFREG|0664, st_nlink=1, st_uid=1000, st_gid=1000, st_blksize=4096, st_blocks=8, st_size=18, st_atime=2017/03/20-20:35:54, st_mtime=2017/03/20-20:35:06, st_ctime=2017/03/20-20:35:06}) = 0
13887 open("/mnt/c/test.txt", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 4
13887 ioctl(4, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0xbffff1d8) = -1 ENOTTY (Inappropriate ioctl for device)
13887 _llseek(4, 0, [0], SEEK_CUR)      = 0
13887 fstat64(4, {st_dev=makedev(8, 33), st_ino=13, st_mode=S_IFREG|0664, st_nlink=1, st_uid=1000, st_gid=1000, st_blksize=4096, st_blocks=0, st_size=0, st_atime=2017/03/20-20:36:08, st_mtime=2017/03/20-20:36:08, st_ctime=2017/03/20-20:36:08}) = 0
13887 fcntl64(4, F_SETFD, FD_CLOEXEC)   = 0
13887 read(3, "This is test data\n", 1024) = 18
13887 write(4, "This is test data\n", 18) = 18
13887 read(3, "", 1024)                 = 0
13887 close(4)                          = -1 EIO (IO ERROR)
13887 close(3)                          = 0
13887 rt_sigaction(SIGHUP, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGINT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGQUIT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGILL, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGTRAP, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGABRT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGBUS, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGFPE, NULL, {SIG_IGN, [FPE], SA_RESTORER|SA_RESTART, 0xb7dc20f8}, 8) = 0
13887 rt_sigaction(SIGKILL, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGUSR1, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGSEGV, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGUSR2, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGPIPE, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGALRM, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGTERM, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGSTKFLT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGCONT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGSTOP, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGTSTP, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGTTIN, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGTTOU, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGURG, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGXCPU, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGXFSZ, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGVTALRM, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGPROF, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGWINCH, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGIO, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGPWR, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGSYS, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_2, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_3, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_4, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_5, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_6, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_7, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_8, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_9, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_10, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_11, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_12, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_13, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_14, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_15, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_16, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_17, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_18, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_19, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_20, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_21, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_22, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_23, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_24, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_25, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_26, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_27, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_28, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_29, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_30, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_31, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGRT_32, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGABRT, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGIO, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 rt_sigaction(SIGSYS, NULL, {SIG_DFL, [], 0}, 8) = 0
13887 exit_group(0)                     = ?
13887 +++ exited with 0 +++
